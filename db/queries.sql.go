// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkConnectionExists = `-- name: CheckConnectionExists :one
SELECT id FROM connection_relationships 
WHERE ((profile_a_id = $1 AND profile_b_id = $2) OR (profile_a_id = $2 AND profile_b_id = $1)) 
AND degree = $3
`

type CheckConnectionExistsParams struct {
	ProfileAID pgtype.UUID
	ProfileBID pgtype.UUID
	Degree     int32
}

func (q *Queries) CheckConnectionExists(ctx context.Context, arg CheckConnectionExistsParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, checkConnectionExists, arg.ProfileAID, arg.ProfileBID, arg.Degree)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createAutomationRule = `-- name: CreateAutomationRule :one
INSERT INTO automation_rules (user_id, name, company_filter, location_filter, action_type, message_template)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, name, company_filter, location_filter, action_type, message_template, is_active, created_at
`

type CreateAutomationRuleParams struct {
	UserID          pgtype.UUID
	Name            string
	CompanyFilter   pgtype.Text
	LocationFilter  pgtype.Text
	ActionType      string
	MessageTemplate pgtype.Text
}

func (q *Queries) CreateAutomationRule(ctx context.Context, arg CreateAutomationRuleParams) (AutomationRule, error) {
	row := q.db.QueryRow(ctx, createAutomationRule,
		arg.UserID,
		arg.Name,
		arg.CompanyFilter,
		arg.LocationFilter,
		arg.ActionType,
		arg.MessageTemplate,
	)
	var i AutomationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CompanyFilter,
		&i.LocationFilter,
		&i.ActionType,
		&i.MessageTemplate,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createCompany = `-- name: CreateCompany :one
INSERT INTO companies (name, linkedin_url, industry)
VALUES ($1, $2, $3)
RETURNING id, name, linkedin_url, industry, created_at, updated_at
`

type CreateCompanyParams struct {
	Name        string
	LinkedinUrl pgtype.Text
	Industry    pgtype.Text
}

func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, createCompany, arg.Name, arg.LinkedinUrl, arg.Industry)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LinkedinUrl,
		&i.Industry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createConnectionRelationship = `-- name: CreateConnectionRelationship :one
INSERT INTO connection_relationships (profile_a_id, profile_b_id, degree, discovered_by_user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, profile_a_id, profile_b_id, degree, discovered_at, discovered_by_user_id
`

type CreateConnectionRelationshipParams struct {
	ProfileAID         pgtype.UUID
	ProfileBID         pgtype.UUID
	Degree             int32
	DiscoveredByUserID pgtype.UUID
}

func (q *Queries) CreateConnectionRelationship(ctx context.Context, arg CreateConnectionRelationshipParams) (ConnectionRelationship, error) {
	row := q.db.QueryRow(ctx, createConnectionRelationship,
		arg.ProfileAID,
		arg.ProfileBID,
		arg.Degree,
		arg.DiscoveredByUserID,
	)
	var i ConnectionRelationship
	err := row.Scan(
		&i.ID,
		&i.ProfileAID,
		&i.ProfileBID,
		&i.Degree,
		&i.DiscoveredAt,
		&i.DiscoveredByUserID,
	)
	return i, err
}

const createLinkedInProfile = `-- name: CreateLinkedInProfile :one
INSERT INTO linkedin_profiles (linkedin_url, name, location, current_company_id, headline)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, linkedin_url, name, location, current_company_id, headline, created_at, updated_at
`

type CreateLinkedInProfileParams struct {
	LinkedinUrl      string
	Name             string
	Location         pgtype.Text
	CurrentCompanyID pgtype.UUID
	Headline         pgtype.Text
}

func (q *Queries) CreateLinkedInProfile(ctx context.Context, arg CreateLinkedInProfileParams) (LinkedinProfile, error) {
	row := q.db.QueryRow(ctx, createLinkedInProfile,
		arg.LinkedinUrl,
		arg.Name,
		arg.Location,
		arg.CurrentCompanyID,
		arg.Headline,
	)
	var i LinkedinProfile
	err := row.Scan(
		&i.ID,
		&i.LinkedinUrl,
		&i.Name,
		&i.Location,
		&i.CurrentCompanyID,
		&i.Headline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProfileCompany = `-- name: CreateProfileCompany :one
INSERT INTO profile_companies (profile_id, company_id, position, start_date, end_date, is_current)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, profile_id, company_id, position, start_date, end_date, is_current, created_at
`

type CreateProfileCompanyParams struct {
	ProfileID pgtype.UUID
	CompanyID pgtype.UUID
	Position  string
	StartDate pgtype.Date
	EndDate   pgtype.Date
	IsCurrent bool
}

func (q *Queries) CreateProfileCompany(ctx context.Context, arg CreateProfileCompanyParams) (ProfileCompany, error) {
	row := q.db.QueryRow(ctx, createProfileCompany,
		arg.ProfileID,
		arg.CompanyID,
		arg.Position,
		arg.StartDate,
		arg.EndDate,
		arg.IsCurrent,
	)
	var i ProfileCompany
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.CompanyID,
		&i.Position,
		&i.StartDate,
		&i.EndDate,
		&i.IsCurrent,
		&i.CreatedAt,
	)
	return i, err
}

const createTrackedConnection = `-- name: CreateTrackedConnection :one
INSERT INTO tracked_connections (user_id, profile_id)
VALUES ($1, $2)
RETURNING id, user_id, profile_id, created_at, last_checked_at
`

type CreateTrackedConnectionParams struct {
	UserID    pgtype.UUID
	ProfileID pgtype.UUID
}

func (q *Queries) CreateTrackedConnection(ctx context.Context, arg CreateTrackedConnectionParams) (TrackedConnection, error) {
	row := q.db.QueryRow(ctx, createTrackedConnection, arg.UserID, arg.ProfileID)
	var i TrackedConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.CreatedAt,
		&i.LastCheckedAt,
	)
	return i, err
}

const createUserWithBoth = `-- name: CreateUserWithBoth :one
INSERT INTO users (email, name, password_hash, google_id, access_token, refresh_token, auth_type)
VALUES ($1, $2, $3, $4, $5, $6, 'both')
RETURNING id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
`

type CreateUserWithBothParams struct {
	Email        string
	Name         string
	PasswordHash pgtype.Text
	GoogleID     pgtype.Text
	AccessToken  pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) CreateUserWithBoth(ctx context.Context, arg CreateUserWithBothParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithBoth,
		arg.Email,
		arg.Name,
		arg.PasswordHash,
		arg.GoogleID,
		arg.AccessToken,
		arg.RefreshToken,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithGoogle = `-- name: CreateUserWithGoogle :one
INSERT INTO users (email, name, google_id, access_token, refresh_token, auth_type)
VALUES ($1, $2, $3, $4, $5, 'google')
RETURNING id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
`

type CreateUserWithGoogleParams struct {
	Email        string
	Name         string
	GoogleID     pgtype.Text
	AccessToken  pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) CreateUserWithGoogle(ctx context.Context, arg CreateUserWithGoogleParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithGoogle,
		arg.Email,
		arg.Name,
		arg.GoogleID,
		arg.AccessToken,
		arg.RefreshToken,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithPassword = `-- name: CreateUserWithPassword :one
INSERT INTO users (email, name, password_hash, auth_type)
VALUES ($1, $2, $3, 'password')
RETURNING id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
`

type CreateUserWithPasswordParams struct {
	Email        string
	Name         string
	PasswordHash pgtype.Text
}

func (q *Queries) CreateUserWithPassword(ctx context.Context, arg CreateUserWithPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPassword, arg.Email, arg.Name, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAutomationRule = `-- name: DeleteAutomationRule :exec
DELETE FROM automation_rules 
WHERE id = $1 AND user_id = $2
`

type DeleteAutomationRuleParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeleteAutomationRule(ctx context.Context, arg DeleteAutomationRuleParams) error {
	_, err := q.db.Exec(ctx, deleteAutomationRule, arg.ID, arg.UserID)
	return err
}

const deleteProfileCompany = `-- name: DeleteProfileCompany :exec
DELETE FROM profile_companies 
WHERE profile_id = $1 AND company_id = $2
`

type DeleteProfileCompanyParams struct {
	ProfileID pgtype.UUID
	CompanyID pgtype.UUID
}

func (q *Queries) DeleteProfileCompany(ctx context.Context, arg DeleteProfileCompanyParams) error {
	_, err := q.db.Exec(ctx, deleteProfileCompany, arg.ProfileID, arg.CompanyID)
	return err
}

const deleteTrackedConnection = `-- name: DeleteTrackedConnection :exec
DELETE FROM tracked_connections 
WHERE user_id = $1 AND profile_id = $2
`

type DeleteTrackedConnectionParams struct {
	UserID    pgtype.UUID
	ProfileID pgtype.UUID
}

func (q *Queries) DeleteTrackedConnection(ctx context.Context, arg DeleteTrackedConnectionParams) error {
	_, err := q.db.Exec(ctx, deleteTrackedConnection, arg.UserID, arg.ProfileID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getActiveAutomationRules = `-- name: GetActiveAutomationRules :many
SELECT id, user_id, name, company_filter, location_filter, action_type, message_template, is_active, created_at
FROM automation_rules
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) GetActiveAutomationRules(ctx context.Context, userID pgtype.UUID) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, getActiveAutomationRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutomationRule
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CompanyFilter,
			&i.LocationFilter,
			&i.ActionType,
			&i.MessageTemplate,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationRuleByID = `-- name: GetAutomationRuleByID :one
SELECT id, user_id, name, company_filter, location_filter, action_type, message_template, is_active, created_at
FROM automation_rules
WHERE id = $1 AND user_id = $2
`

type GetAutomationRuleByIDParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) GetAutomationRuleByID(ctx context.Context, arg GetAutomationRuleByIDParams) (AutomationRule, error) {
	row := q.db.QueryRow(ctx, getAutomationRuleByID, arg.ID, arg.UserID)
	var i AutomationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CompanyFilter,
		&i.LocationFilter,
		&i.ActionType,
		&i.MessageTemplate,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getAutomationRules = `-- name: GetAutomationRules :many
SELECT id, user_id, name, company_filter, location_filter, action_type, message_template, is_active, created_at
FROM automation_rules
WHERE user_id = $1
ORDER BY created_at DESC
`

// Automation Rules queries
func (q *Queries) GetAutomationRules(ctx context.Context, userID pgtype.UUID) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, getAutomationRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutomationRule
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CompanyFilter,
			&i.LocationFilter,
			&i.ActionType,
			&i.MessageTemplate,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT id, name, linkedin_url, industry, created_at, updated_at
FROM companies
WHERE id = $1
`

// Companies queries
func (q *Queries) GetCompanyByID(ctx context.Context, id pgtype.UUID) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LinkedinUrl,
		&i.Industry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyByLinkedInURL = `-- name: GetCompanyByLinkedInURL :one
SELECT id, name, linkedin_url, industry, created_at, updated_at
FROM companies
WHERE linkedin_url = $1
`

func (q *Queries) GetCompanyByLinkedInURL(ctx context.Context, linkedinUrl pgtype.Text) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByLinkedInURL, linkedinUrl)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LinkedinUrl,
		&i.Industry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyByName = `-- name: GetCompanyByName :one
SELECT id, name, linkedin_url, industry, created_at, updated_at
FROM companies
WHERE name = $1
`

func (q *Queries) GetCompanyByName(ctx context.Context, name string) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByName, name)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LinkedinUrl,
		&i.Industry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConnectionRelationships = `-- name: GetConnectionRelationships :many
SELECT cr.id, cr.profile_a_id, cr.profile_b_id, cr.degree, cr.discovered_at, cr.discovered_by_user_id,
       lp1.name as profile_a_name, lp1.linkedin_url as profile_a_url,
       lp2.name as profile_b_name, lp2.linkedin_url as profile_b_url
FROM connection_relationships cr
JOIN linkedin_profiles lp1 ON cr.profile_a_id = lp1.id
JOIN linkedin_profiles lp2 ON cr.profile_b_id = lp2.id
WHERE cr.profile_a_id = $1 OR cr.profile_b_id = $1
ORDER BY cr.degree, cr.discovered_at DESC
`

type GetConnectionRelationshipsRow struct {
	ID                 pgtype.UUID
	ProfileAID         pgtype.UUID
	ProfileBID         pgtype.UUID
	Degree             int32
	DiscoveredAt       pgtype.Timestamp
	DiscoveredByUserID pgtype.UUID
	ProfileAName       string
	ProfileAUrl        string
	ProfileBName       string
	ProfileBUrl        string
}

// Connection Relationships queries
func (q *Queries) GetConnectionRelationships(ctx context.Context, profileAID pgtype.UUID) ([]GetConnectionRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, getConnectionRelationships, profileAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionRelationshipsRow
	for rows.Next() {
		var i GetConnectionRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileAID,
			&i.ProfileBID,
			&i.Degree,
			&i.DiscoveredAt,
			&i.DiscoveredByUserID,
			&i.ProfileAName,
			&i.ProfileAUrl,
			&i.ProfileBName,
			&i.ProfileBUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnectionsByDegree = `-- name: GetConnectionsByDegree :many
SELECT cr.id, cr.profile_a_id, cr.profile_b_id, cr.degree, cr.discovered_at, cr.discovered_by_user_id,
       lp1.name as profile_a_name, lp1.linkedin_url as profile_a_url,
       lp2.name as profile_b_name, lp2.linkedin_url as profile_b_url
FROM connection_relationships cr
JOIN linkedin_profiles lp1 ON cr.profile_a_id = lp1.id
JOIN linkedin_profiles lp2 ON cr.profile_b_id = lp2.id
WHERE (cr.profile_a_id = $1 OR cr.profile_b_id = $1) AND cr.degree = $2
ORDER BY cr.discovered_at DESC
`

type GetConnectionsByDegreeParams struct {
	ProfileAID pgtype.UUID
	Degree     int32
}

type GetConnectionsByDegreeRow struct {
	ID                 pgtype.UUID
	ProfileAID         pgtype.UUID
	ProfileBID         pgtype.UUID
	Degree             int32
	DiscoveredAt       pgtype.Timestamp
	DiscoveredByUserID pgtype.UUID
	ProfileAName       string
	ProfileAUrl        string
	ProfileBName       string
	ProfileBUrl        string
}

func (q *Queries) GetConnectionsByDegree(ctx context.Context, arg GetConnectionsByDegreeParams) ([]GetConnectionsByDegreeRow, error) {
	rows, err := q.db.Query(ctx, getConnectionsByDegree, arg.ProfileAID, arg.Degree)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionsByDegreeRow
	for rows.Next() {
		var i GetConnectionsByDegreeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileAID,
			&i.ProfileBID,
			&i.Degree,
			&i.DiscoveredAt,
			&i.DiscoveredByUserID,
			&i.ProfileAName,
			&i.ProfileAUrl,
			&i.ProfileBName,
			&i.ProfileBUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkedInProfileByID = `-- name: GetLinkedInProfileByID :one
SELECT id, linkedin_url, name, location, current_company_id, headline, created_at, updated_at
FROM linkedin_profiles
WHERE id = $1
`

// LinkedIn Profiles queries
func (q *Queries) GetLinkedInProfileByID(ctx context.Context, id pgtype.UUID) (LinkedinProfile, error) {
	row := q.db.QueryRow(ctx, getLinkedInProfileByID, id)
	var i LinkedinProfile
	err := row.Scan(
		&i.ID,
		&i.LinkedinUrl,
		&i.Name,
		&i.Location,
		&i.CurrentCompanyID,
		&i.Headline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLinkedInProfileByURL = `-- name: GetLinkedInProfileByURL :one
SELECT id, linkedin_url, name, location, current_company_id, headline, created_at, updated_at
FROM linkedin_profiles
WHERE linkedin_url = $1
`

func (q *Queries) GetLinkedInProfileByURL(ctx context.Context, linkedinUrl string) (LinkedinProfile, error) {
	row := q.db.QueryRow(ctx, getLinkedInProfileByURL, linkedinUrl)
	var i LinkedinProfile
	err := row.Scan(
		&i.ID,
		&i.LinkedinUrl,
		&i.Name,
		&i.Location,
		&i.CurrentCompanyID,
		&i.Headline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNewConnectionsForUser = `-- name: GetNewConnectionsForUser :many
SELECT DISTINCT lp.id, lp.linkedin_url, lp.name, lp.location, lp.headline, lp.created_at,
       c.name as company_name,
       MIN(cr.degree) as connection_degree
FROM linkedin_profiles lp
LEFT JOIN companies c ON lp.current_company_id = c.id
JOIN connection_relationships cr ON (cr.profile_a_id = lp.id OR cr.profile_b_id = lp.id)
JOIN tracked_connections tc ON (
    (cr.profile_a_id = tc.profile_id AND cr.profile_b_id = lp.id) OR
    (cr.profile_b_id = tc.profile_id AND cr.profile_a_id = lp.id)
)
WHERE tc.user_id = $1 
  AND lp.id NOT IN (
    SELECT DISTINCT tc2.profile_id 
    FROM tracked_connections tc2 
    WHERE tc2.user_id = $1
  )
  AND cr.discovered_at > $2
GROUP BY lp.id, lp.linkedin_url, lp.name, lp.location, lp.headline, lp.created_at, c.name
ORDER BY lp.created_at DESC
`

type GetNewConnectionsForUserParams struct {
	UserID       pgtype.UUID
	DiscoveredAt pgtype.Timestamp
}

type GetNewConnectionsForUserRow struct {
	ID               pgtype.UUID
	LinkedinUrl      string
	Name             string
	Location         pgtype.Text
	Headline         pgtype.Text
	CreatedAt        pgtype.Timestamp
	CompanyName      pgtype.Text
	ConnectionDegree interface{}
}

// Business Logic queries
func (q *Queries) GetNewConnectionsForUser(ctx context.Context, arg GetNewConnectionsForUserParams) ([]GetNewConnectionsForUserRow, error) {
	rows, err := q.db.Query(ctx, getNewConnectionsForUser, arg.UserID, arg.DiscoveredAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewConnectionsForUserRow
	for rows.Next() {
		var i GetNewConnectionsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.LinkedinUrl,
			&i.Name,
			&i.Location,
			&i.Headline,
			&i.CreatedAt,
			&i.CompanyName,
			&i.ConnectionDegree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileCompanies = `-- name: GetProfileCompanies :many
SELECT pc.id, pc.profile_id, pc.company_id, pc.position, pc.start_date, pc.end_date, pc.is_current, pc.created_at,
       c.name as company_name, c.linkedin_url as company_linkedin_url
FROM profile_companies pc
JOIN companies c ON pc.company_id = c.id
WHERE pc.profile_id = $1
ORDER BY pc.start_date DESC
`

type GetProfileCompaniesRow struct {
	ID                 pgtype.UUID
	ProfileID          pgtype.UUID
	CompanyID          pgtype.UUID
	Position           string
	StartDate          pgtype.Date
	EndDate            pgtype.Date
	IsCurrent          bool
	CreatedAt          pgtype.Timestamp
	CompanyName        string
	CompanyLinkedinUrl pgtype.Text
}

// Profile Companies (Employment History) queries
func (q *Queries) GetProfileCompanies(ctx context.Context, profileID pgtype.UUID) ([]GetProfileCompaniesRow, error) {
	rows, err := q.db.Query(ctx, getProfileCompanies, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfileCompaniesRow
	for rows.Next() {
		var i GetProfileCompaniesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.CompanyID,
			&i.Position,
			&i.StartDate,
			&i.EndDate,
			&i.IsCurrent,
			&i.CreatedAt,
			&i.CompanyName,
			&i.CompanyLinkedinUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesMatchingRules = `-- name: GetProfilesMatchingRules :many
SELECT lp.id, lp.linkedin_url, lp.name, lp.location, lp.headline,
       c.name as company_name,
       ar.id as rule_id, ar.name as rule_name, ar.action_type, ar.message_template
FROM linkedin_profiles lp
LEFT JOIN companies c ON lp.current_company_id = c.id
CROSS JOIN automation_rules ar
WHERE ar.user_id = $1 
  AND ar.is_active = true
  AND (ar.company_filter IS NULL OR c.name ILIKE '%' || ar.company_filter || '%')
  AND (ar.location_filter IS NULL OR lp.location ILIKE '%' || ar.location_filter || '%')
  AND lp.id NOT IN (
    SELECT DISTINCT tc.profile_id 
    FROM tracked_connections tc 
    WHERE tc.user_id = $1
  )
`

type GetProfilesMatchingRulesRow struct {
	ID              pgtype.UUID
	LinkedinUrl     string
	Name            string
	Location        pgtype.Text
	Headline        pgtype.Text
	CompanyName     pgtype.Text
	RuleID          pgtype.UUID
	RuleName        string
	ActionType      string
	MessageTemplate pgtype.Text
}

func (q *Queries) GetProfilesMatchingRules(ctx context.Context, userID pgtype.UUID) ([]GetProfilesMatchingRulesRow, error) {
	rows, err := q.db.Query(ctx, getProfilesMatchingRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesMatchingRulesRow
	for rows.Next() {
		var i GetProfilesMatchingRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.LinkedinUrl,
			&i.Name,
			&i.Location,
			&i.Headline,
			&i.CompanyName,
			&i.RuleID,
			&i.RuleName,
			&i.ActionType,
			&i.MessageTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrackedConnection = `-- name: GetTrackedConnection :one
SELECT tc.id, tc.user_id, tc.profile_id, tc.created_at, tc.last_checked_at
FROM tracked_connections tc
WHERE tc.user_id = $1 AND tc.profile_id = $2
`

type GetTrackedConnectionParams struct {
	UserID    pgtype.UUID
	ProfileID pgtype.UUID
}

func (q *Queries) GetTrackedConnection(ctx context.Context, arg GetTrackedConnectionParams) (TrackedConnection, error) {
	row := q.db.QueryRow(ctx, getTrackedConnection, arg.UserID, arg.ProfileID)
	var i TrackedConnection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.CreatedAt,
		&i.LastCheckedAt,
	)
	return i, err
}

const getTrackedConnections = `-- name: GetTrackedConnections :many
SELECT tc.id, tc.user_id, tc.profile_id, tc.created_at, tc.last_checked_at,
       lp.linkedin_url, lp.name, lp.location, lp.headline,
       c.name as company_name
FROM tracked_connections tc
JOIN linkedin_profiles lp ON tc.profile_id = lp.id
LEFT JOIN companies c ON lp.current_company_id = c.id
WHERE tc.user_id = $1
ORDER BY tc.last_checked_at DESC
`

type GetTrackedConnectionsRow struct {
	ID            pgtype.UUID
	UserID        pgtype.UUID
	ProfileID     pgtype.UUID
	CreatedAt     pgtype.Timestamp
	LastCheckedAt pgtype.Timestamp
	LinkedinUrl   string
	Name          string
	Location      pgtype.Text
	Headline      pgtype.Text
	CompanyName   pgtype.Text
}

// Tracked Connections queries
func (q *Queries) GetTrackedConnections(ctx context.Context, userID pgtype.UUID) ([]GetTrackedConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getTrackedConnections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrackedConnectionsRow
	for rows.Next() {
		var i GetTrackedConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.CreatedAt,
			&i.LastCheckedAt,
			&i.LinkedinUrl,
			&i.Name,
			&i.Location,
			&i.Headline,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
FROM users
WHERE google_id = $1
`

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, name, password_hash, google_id, access_token, refresh_token, auth_type, is_active, created_at, updated_at
FROM users
WHERE id = $1
`

// Users queries
func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.GoogleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AuthType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCompanies = `-- name: ListCompanies :many
SELECT id, name, linkedin_url, industry, created_at, updated_at
FROM companies
ORDER BY name
`

func (q *Queries) ListCompanies(ctx context.Context) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LinkedinUrl,
			&i.Industry,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedInProfiles = `-- name: ListLinkedInProfiles :many
SELECT id, linkedin_url, name, location, current_company_id, headline, created_at, updated_at
FROM linkedin_profiles
ORDER BY name
`

func (q *Queries) ListLinkedInProfiles(ctx context.Context) ([]LinkedinProfile, error) {
	rows, err := q.db.Query(ctx, listLinkedInProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LinkedinProfile
	for rows.Next() {
		var i LinkedinProfile
		if err := rows.Scan(
			&i.ID,
			&i.LinkedinUrl,
			&i.Name,
			&i.Location,
			&i.CurrentCompanyID,
			&i.Headline,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, name, auth_type, is_active, created_at, updated_at
FROM users
ORDER BY created_at DESC
`

type ListUsersRow struct {
	ID        pgtype.UUID
	Email     string
	Name      string
	AuthType  string
	IsActive  bool
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.AuthType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pingDb = `-- name: PingDb :one
SELECT 1 as result
`

// Utility queries
func (q *Queries) PingDb(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, pingDb)
	var result int32
	err := row.Scan(&result)
	return result, err
}

const updateAutomationRule = `-- name: UpdateAutomationRule :exec
UPDATE automation_rules 
SET name = $3, company_filter = $4, location_filter = $5, action_type = $6, message_template = $7, is_active = $8
WHERE id = $1 AND user_id = $2
`

type UpdateAutomationRuleParams struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	Name            string
	CompanyFilter   pgtype.Text
	LocationFilter  pgtype.Text
	ActionType      string
	MessageTemplate pgtype.Text
	IsActive        bool
}

func (q *Queries) UpdateAutomationRule(ctx context.Context, arg UpdateAutomationRuleParams) error {
	_, err := q.db.Exec(ctx, updateAutomationRule,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.CompanyFilter,
		arg.LocationFilter,
		arg.ActionType,
		arg.MessageTemplate,
		arg.IsActive,
	)
	return err
}

const updateCompany = `-- name: UpdateCompany :exec
UPDATE companies 
SET name = $2, linkedin_url = $3, industry = $4, updated_at = NOW()
WHERE id = $1
`

type UpdateCompanyParams struct {
	ID          pgtype.UUID
	Name        string
	LinkedinUrl pgtype.Text
	Industry    pgtype.Text
}

func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) error {
	_, err := q.db.Exec(ctx, updateCompany,
		arg.ID,
		arg.Name,
		arg.LinkedinUrl,
		arg.Industry,
	)
	return err
}

const updateLinkedInProfile = `-- name: UpdateLinkedInProfile :exec
UPDATE linkedin_profiles 
SET name = $2, location = $3, current_company_id = $4, headline = $5, updated_at = NOW()
WHERE id = $1
`

type UpdateLinkedInProfileParams struct {
	ID               pgtype.UUID
	Name             string
	Location         pgtype.Text
	CurrentCompanyID pgtype.UUID
	Headline         pgtype.Text
}

func (q *Queries) UpdateLinkedInProfile(ctx context.Context, arg UpdateLinkedInProfileParams) error {
	_, err := q.db.Exec(ctx, updateLinkedInProfile,
		arg.ID,
		arg.Name,
		arg.Location,
		arg.CurrentCompanyID,
		arg.Headline,
	)
	return err
}

const updateProfileCompany = `-- name: UpdateProfileCompany :exec
UPDATE profile_companies 
SET position = $3, start_date = $4, end_date = $5, is_current = $6
WHERE profile_id = $1 AND company_id = $2
`

type UpdateProfileCompanyParams struct {
	ProfileID pgtype.UUID
	CompanyID pgtype.UUID
	Position  string
	StartDate pgtype.Date
	EndDate   pgtype.Date
	IsCurrent bool
}

func (q *Queries) UpdateProfileCompany(ctx context.Context, arg UpdateProfileCompanyParams) error {
	_, err := q.db.Exec(ctx, updateProfileCompany,
		arg.ProfileID,
		arg.CompanyID,
		arg.Position,
		arg.StartDate,
		arg.EndDate,
		arg.IsCurrent,
	)
	return err
}

const updateTrackedConnectionLastChecked = `-- name: UpdateTrackedConnectionLastChecked :exec
UPDATE tracked_connections 
SET last_checked_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateTrackedConnectionLastChecked(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateTrackedConnectionLastChecked, id)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users 
SET name = $2, email = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID    pgtype.UUID
	Name  string
	Email string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	return err
}

const updateUserActiveStatus = `-- name: UpdateUserActiveStatus :exec
UPDATE users 
SET is_active = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserActiveStatusParams struct {
	ID       pgtype.UUID
	IsActive bool
}

func (q *Queries) UpdateUserActiveStatus(ctx context.Context, arg UpdateUserActiveStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserActiveStatus, arg.ID, arg.IsActive)
	return err
}

const updateUserGoogleAuth = `-- name: UpdateUserGoogleAuth :exec
UPDATE users 
SET google_id = $2, access_token = $3, refresh_token = $4, auth_type = CASE 
  WHEN auth_type = 'password' THEN 'both' 
  ELSE 'google' 
END, updated_at = NOW()
WHERE id = $1
`

type UpdateUserGoogleAuthParams struct {
	ID           pgtype.UUID
	GoogleID     pgtype.Text
	AccessToken  pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) UpdateUserGoogleAuth(ctx context.Context, arg UpdateUserGoogleAuthParams) error {
	_, err := q.db.Exec(ctx, updateUserGoogleAuth,
		arg.ID,
		arg.GoogleID,
		arg.AccessToken,
		arg.RefreshToken,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users 
SET password_hash = $2, auth_type = CASE 
  WHEN auth_type = 'google' THEN 'both' 
  ELSE 'password' 
END, updated_at = NOW()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID
	PasswordHash pgtype.Text
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserTokens = `-- name: UpdateUserTokens :exec
UPDATE users 
SET access_token = $2, refresh_token = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateUserTokensParams struct {
	ID           pgtype.UUID
	AccessToken  pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) UpdateUserTokens(ctx context.Context, arg UpdateUserTokensParams) error {
	_, err := q.db.Exec(ctx, updateUserTokens, arg.ID, arg.AccessToken, arg.RefreshToken)
	return err
}
